//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include "MooseUtils.h"
#include "MooseInit.h"
#include "InputParameters.h"
#include "ActionFactory.h"
#include "Action.h"
#include "Factory.h"
#include "MooseObjectAction.h"
#include "MooseADObjectAction.h"
#include "ActionWarehouse.h"
#include "EmptyAction.h"
#include "FEProblem.h"
#include "MooseMesh.h"
#include "Executioner.h"
#include "MooseApp.h"
#include "MooseEnum.h"
#include "MultiMooseEnum.h"
#include "MultiApp.h"
#include "GlobalParamsAction.h"
#include "SyntaxTree.h"
#include "InputFileFormatter.h"
#include "YAMLFormatter.h"
#include "MooseTypes.h"
#include "CommandLine.h"
#include "JsonSyntaxTree.h"
#include "SystemInfo.h"
#include "MooseUtils.h"

#include "libmesh/parallel.h"

// Regular expression includes
#include "pcrecpp.h"

// C++ includes
#include <string>
#include <map>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <cstdlib>

Parser::Parser(MooseApp & app, ActionWarehouse & action_wh)
  : ConsoleStreamInterface(app),
    _app(app),
    _factory(app.getFactory()),
    _action_wh(action_wh),
    _action_factory(app.getActionFactory()),
    _syntax(_action_wh.syntax()),
    _syntax_formatter(nullptr),
    _sections_read(false),
    _current_params(nullptr),
    _current_error_stream(nullptr)
{
}

Parser::~Parser() {}

bool
isSectionActive(std::string path, hit::Node * root)
{
  hit::Node * n = root->find(path);
  while (n)
  {
    hit::Node * section = n->parent();
    if (section)
    {
      auto actives = section->find("active");
      auto inactives = section->find("inactive");

      // only check current level, not nested ones
      if (actives && actives->type() == hit::NodeType::Field && actives->parent() == section)
      {
        auto vars = section->param<std::vector<std::string>>("active");
        bool have_var = false;
        for (auto & var : vars)
          if (n->path() == hit::pathNorm(var))
            have_var = true;
        if (!have_var)
          return false;
      }
      // only check current level, not nested ones
      if (inactives && inactives->type() == hit::NodeType::Field && inactives->parent() == section)
      {
        auto vars = section->param<std::vector<std::string>>("inactive");
        for (auto & var : vars)
          if (n->path() == hit::pathNorm(var))
            return false;
      }
    }
    n = section;
  }
  return true;
}

class DupParamWalker : public hit::Walker
{
public:
  DupParamWalker(std::string fname) : _fname(fname) {}
  void walk(const std::string & fullpath, const std::string & /*nodepath*/, hit::Node * n) override
  {
    std::string prefix = n->type() == hit::NodeType::Field ? "parameter" : "section";

    if (_have.count(fullpath) > 0)
    {
      auto existing = _have[fullpath];
      if (_duplicates.count(fullpath) == 0)
      {
        errors.push_back(
            errormsg(_fname, existing, prefix, " '", fullpath, "' supplied multiple times"));
        _duplicates.insert(fullpath);
      }
      errors.push_back(errormsg(_fname, n, prefix, " '", fullpath, "' supplied multiple times"));
    }
    _have[n->fullpath()] = n;
  }

  std::vector<std::string> errors;

private:
  std::string _fname;
  std::set<std::string> _duplicates;
  std::map<std::string, hit::Node *> _have;
};

std::vector<std::string>
findSimilar(std::string param, std::vector<std::string> options)
{
  std::vector<std::string> candidates;
  if (options.size() == 0)
    return candidates;

  int mindist = MooseUtils::levenshteinDist(options[0], param);
  for (auto & opt : options)
  {
    int dist = MooseUtils::levenshteinDist(opt, param);
    // magic number heuristics to get similarity distance cutoff
    int dist_cutoff = 1 + param.size() / 5;
    if (dist > dist_cutoff || dist > mindist)
      continue;

    if (dist < mindist)
    {
      mindist = dist;
      candidates.clear();
    }
    candidates.push_back(opt);
  }
  return candidates;
}

std::vector<std::string>
Parser::listValidParams(std::string & section_name)
{
  bool dummy;
  std::string registered_identifier = _syntax.isAssociated(section_name, &dummy);
  auto iters = _syntax.getActions(registered_identifier);

  std::vector<std::string> paramlist;
  for (auto it = iters.first; it != iters.second; ++it)
  {
    auto params = _action_factory.getValidParams(it->second._action);
    for (const auto & it : params)
      paramlist.push_back(it.first);
  }
  return paramlist;
}

class UnusedWalker : public hit::Walker
{
public:
  UnusedWalker(std::string fname, std::set<std::string> used, Parser & p)
    : _fname(fname), _used(used), _parser(p)
  {
  }

  void walk(const std::string & fullpath, const std::string & nodename, hit::Node * n) override
  {
    // the line() > 0 check allows us to skip nodes that were merged into this tree (i.e. CLI
    // args) because their unused params are checked+reported independently of the ones in the
    // main tree.
    if (!_used.count(fullpath) && nodename != "active" && nodename != "inactive" &&
        isSectionActive(fullpath, n->root()) && n->line() > 0)
    {
      auto section_name = fullpath.substr(0, fullpath.rfind("/"));
      auto paramlist = _parser.listValidParams(section_name);
      auto candidates = findSimilar(nodename, paramlist);
      if (candidates.size() > 0)
        errors.push_back(errormsg(_fname,
                                  n,
                                  "unused parameter '",
                                  fullpath,
                                  "'\n",
                                  "      Did you mean '",
                                  candidates[0],
                                  "'?"));
      else
        errors.push_back(errormsg(_fname, n, "unused parameter '", fullpath, "'"));
    }
  }

  std::vector<std::string> errors;

private:
  std::string _fname;
  std::set<std::string> _used;
  Parser & _parser;
};

class BadActiveWalker : public hit::Walker
{
public:
  BadActiveWalker(std::string fname) : _fname(fname) {}
  void walk(const std::string & /*fullpath*/,
            const std::string & /*nodepath*/,
            hit::Node * section) override
  {
    auto actives = section->find("active");
    auto inactives = section->find("inactive");

    if (actives && inactives && actives->type() == hit::NodeType::Field &&
        inactives->type() == hit::NodeType::Field && actives->parent() == inactives->parent())
    {
      errors.push_back(
          errormsg(_fname, section, "'active' and 'inactive' parameters both provided in section"));
      return;
    }

    // ensures we don't recheck deeper nesting levels
    if (actives && actives->type() == hit::NodeType::Field && actives->parent() == section)
    {
      auto vars = section->param<std::vector<std::string>>("active");
      std::string msg = "";
      for (auto & var : vars)
      {
        if (!section->find(var))
          msg += var + ", ";
      }
      if (msg.size() > 0)
      {
        msg = msg.substr(0, msg.size() - 2);
        errors.push_back(errormsg(_fname,
                                  section,
                                  "variables listed as active (",
                                  msg,
                                  ") in section '",
                                  section->fullpath(),
                                  "' not found in input"));
      }
    }
    // ensures we don't recheck deeper nesting levels
    if (inactives && inactives->type() == hit::NodeType::Field && inactives->parent() == section)
    {
      auto vars = section->param<std::vector<std::string>>("inactive");
      std::string msg = "";
      for (auto & var : vars)
      {
        if (!section->find(var))
          msg += var + ", ";
      }
      if (msg.size() > 0)
      {
        msg = msg.substr(0, msg.size() - 2);
        errors.push_back(errormsg(_fname,
                                  section,
                                  "variables listed as inactive (",
                                  msg,
                                  ") in section '",
                                  section->fullpath(),
                                  "' not found in input"));
      }
    }
  }
  std::vector<std::string> errors;

private:
  std::string _fname;
};

std::string
Parser::getFileName(bool stripLeadingPath) const
{
  if (!stripLeadingPath)
    return _input_filename;

  std::string filename;
  size_t pos = _input_filename.find_last_of('/');
  if (pos != std::string::npos)
    filename = _input_filename.substr(pos + 1);
  else
    filename = _input_filename;

  return filename;
}

void
Parser::walkRaw(std::string /*fullpath*/, std::string /*nodepath*/, hit::Node * n)
{
  InputParameters active_list_params = validParams<Action>();
  InputParameters params = validParams<EmptyAction>();

  std::string section_name = n->fullpath();
  std::string curr_identifier = n->fullpath();

  // Before we retrieve any actions or build any objects, make sure that the section they are in
  // is active
  if (!isSectionActive(curr_identifier, _root.get()))
    return;

  // Extract the block parameters before constructing the action
  // There may be more than one Action registered for a given section in which case we need to
  // build them all
  bool is_parent;
  std::string registered_identifier = _syntax.isAssociated(section_name, &is_parent);

  // We need to retrieve a list of Actions associated with the current identifier
  auto iters = _syntax.getActions(registered_identifier);
  if (iters.first == iters.second)
  {
    _errmsg += errormsg(getFileName(),
                        n,
                        "section '",
                        curr_identifier,
                        "' does not have an associated \"Action\".\nDid you misspell it?");
    return;
  }

  for (auto it = iters.first; it != iters.second; ++it)
  {
    if (is_parent)
      continue;
    if (_syntax.isDeprecatedSyntax(registered_identifier))
      mooseDeprecated(
          errormsg(getFileName(), n, _syntax.deprecatedActionSyntaxMessage(registered_identifier)));

    params = _action_factory.getValidParams(it->second._action);

    params.set<ActionWarehouse *>("awh") = &_action_wh;

    extractParams(curr_identifier, params);

    // Add the parsed syntax to the parameters object for consumption by the Action
    params.set<std::string>("task") = it->second._task;
    params.set<std::string>("registered_identifier") = registered_identifier;
    params.blockLocation() = _input_filename + ":" + std::to_string(n->line());
    params.blockFullpath() = n->fullpath();

    // Create the Action
    std::shared_ptr<Action> action_obj =
        _action_factory.create(it->second._action, MooseUtils::shortName(curr_identifier), params);

    {
      // extract the MooseObject params if necessary
      std::shared_ptr<MooseObjectAction> object_action =
          std::dynamic_pointer_cast<MooseObjectAction>(action_obj);
      if (object_action)
      {
        object_action->getObjectParams().blockLocation() = params.blockLocation();
        object_action->getObjectParams().blockFullpath() = params.blockFullpath();
        extractParams(curr_identifier, object_action->getObjectParams());
        object_action->getObjectParams()
            .set<std::vector<std::string>>("control_tags")
            .push_back(MooseUtils::baseName(curr_identifier));
      }
    }

    {
      // extract the MooseObject params if necessary
      std::shared_ptr<MooseADObjectAction> object_action =
          std::dynamic_pointer_cast<MooseADObjectAction>(action_obj);
      if (object_action)
      {
        object_action->getObjectParams().blockLocation() = params.blockLocation();
        object_action->getObjectParams().blockFullpath() = params.blockFullpath();
        extractParams(curr_identifier, object_action->getObjectParams());
        object_action->getObjectParams()
            .set<std::vector<std::string>>("control_tags")
            .push_back(MooseUtils::baseName(curr_identifier));
      }
    }

    // add it to the warehouse
    _action_wh.addActionBlock(action_obj);
  }
}

void
Parser::walk(const std::string & fullpath, const std::string & nodepath, hit::Node * n)
{
  // skip sections that were manually processed first.
  for (auto & sec : _secs_need_first)
    if (nodepath == sec)
      return;
  walkRaw(fullpath, nodepath, n);
}

std::string
Parser::hitCLIFilter(std::string appname, int argc, char * argv[])
{
  std::string hit_text;
  bool afterDoubleDash = false;
  for (int i = 1; i < argc; i++)
  {
    std::string arg(argv[i]);

    // all args after a "--" are hit parameters
    if (arg == "--")
    {
      afterDoubleDash = true;
      continue;
    } // otherwise try to guess if a hit params have started by looking for "=" and "/"
    else if (arg.find("=", 0) != std::string::npos)
      afterDoubleDash = true;

    // skip arguments with no equals sign
    if (arg.find("=", 0) == std::string::npos)
      continue;
    // skip cli flags (i.e. start with dash)
    else if (arg.find("-", 0) == 0)
      continue;
    // skip over args that don't look like or are before hit parameters
    else if (!afterDoubleDash)
      continue;
    else if (appname == "main")
    {
      auto pos = arg.find(":", 0);
      if (pos == 0) // trim leading colon
        arg = arg.substr(pos + 1, arg.size() - pos - 1);
      else if (pos != std::string::npos && pos < arg.find("=", 0)) // param is for non-main subapp
        continue;
    }
    else if (appname != "main") // app we are loading is a multiapp subapp
    {
      std::string name;
      std::string num;
      pcrecpp::RE("(.*?)"  // Match the multiapp name
                  "(\\d+)" // math the multiapp number
                  )
          .FullMatch(appname, &name, &num);
      auto pos = arg.find(":", 0);
      if (pos == 0)
        ; // cli param is ":" prefixed meaning global for all main+subapps
      else if (pos == std::string::npos) // param is for main app - skip
        continue;
      else if (arg.substr(0, pos) != appname &&
               arg.substr(0, pos) != name) // param is for different multiapp - skip
      {
        _app.commandLine()->markHitParam(i);
        continue;
      }
      arg = arg.substr(pos + 1, arg.size() - pos - 1); // trim off subapp name prefix
    }

    try
    {
      hit::check("CLI_ARG", arg);
      hit_text += " " + arg;
      // handle case where bash ate quotes around an empty string after the "="
      if (arg.find("=", 0) == arg.size() - 1)
        hit_text += "''";
      _app.commandLine()->markHitParamUsed(i);
    }
    catch (hit::ParseError & err)
    {
      // bash might have eaten quotes around a hit string value or vector
      // so try quoting after the "=" and reparse
      auto quoted = arg;
      auto pos = quoted.find("=", 0);
      if (pos != std::string::npos)
        quoted = arg.substr(0, pos + 1) + "'" + arg.substr(pos + 1, quoted.size() - pos) + "'";
      try
      {
        hit::check("CLI_ARG", quoted);
        hit_text += " " + quoted;
        _app.commandLine()->markHitParamUsed(i);
      }
      catch (hit::ParseError & err)
      {
        mooseError("invalid hit in arg '", arg, "': ", err.what());
      }
    }
  }
  return hit_text;
}

void
Parser::parse(const std::string & input_filename)
{
  // Save the filename
  char abspath[PATH_MAX + 1];
  realpath(input_filename.c_str(), abspath);
  _input_filename = std::string(abspath);

  // vector for initializing active blocks
  std::vector<std::string> all = {"__all__"};

  MooseUtils::checkFileReadable(_input_filename, true);

  std::ifstream f(_input_filename);
  std::string input((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());

  try
  {
    _root.reset(hit::parse(_input_filename, input));

    int argc = _app.commandLine()->argc();
    char ** argv = _app.commandLine()->argv();
    auto cli_input = hitCLIFilter(_app.name(), argc, argv);

    _cli_root.reset(hit::parse("CLI_ARGS", cli_input));
    hit::explode(_cli_root.get());
    hit::explode(_root.get());
    hit::merge(_cli_root.get(), _root.get());
  }
  catch (hit::ParseError & err)
  {
    mooseError(err.what());
  }

  // expand ${bla} parameter values and mark/include variables used in expansions as "used".  This
  // MUST occur before parameter extraction - otherwise parameters will get wrong values.
  ExpandWalker exw(_input_filename);
  _root->walk(&exw);
  for (auto & var : exw.used)
    _extracted_vars.insert(var);
  for (auto & msg : exw.errors)
    _errmsg += msg + "\n";

  // do as much error checking as early as possible so that errors are more useful instead
  // of surprising and disconnected from what caused them.
  DupParamWalker dw(_input_filename);
  BadActiveWalker bw(_input_filename);
  _root->walk(&dw, hit::NodeType::Field);
  _root->walk(&bw, hit::NodeType::Section);
  for (auto & msg : dw.errors)
    _errmsg += msg + "\n";
  for (auto & msg : bw.errors)
    _errmsg += msg + "\n";

  // There are a few order dependent actions that have to be built first in
  // order for the parser and application to function properly:
  //
  // SetupDebugAction: This action can contain an option for monitoring the parser progress. It must
  //                   be parsed first to capture all of the parsing output.
  //
  // GlobalParamsAction: This action is checked during the parameter extraction routines of all
  //                     subsequent blocks. It must be parsed early since it must exist during
  //                     subsequent parameter extraction.
  //
  // DynamicObjectRegistration: This action must be built before any MooseObjectActions are built.
  //                            This is because we retrieve valid parameters from the Factory
  //                            during parse time. Objects must be registered before
  //                            validParameters can be retrieved.
  auto syntax = _syntax.getSyntaxByAction("SetupDebugAction");
  std::copy(syntax.begin(), syntax.end(), std::back_inserter(_secs_need_first));

  syntax = _syntax.getSyntaxByAction("GlobalParamsAction");
  std::copy(syntax.begin(), syntax.end(), std::back_inserter(_secs_need_first));

  syntax = _syntax.getSyntaxByAction("DynamicObjectRegistrationAction");
  std::copy(syntax.begin(), syntax.end(), std::back_inserter(_secs_need_first));

  // walk all the sections extracting paramters from each into InputParameters objects
  for (auto & sec : _secs_need_first)
  {
    auto n = _root->find(sec);
    if (n)
      walkRaw(n->parent()->fullpath(), n->path(), n);
  }
  _root->walk(this, hit::NodeType::Section);

  if (_errmsg.size() > 0)
    mooseError(_errmsg);
}

// Checks the input and the way it has been used and emits any errors/warnings.
// This has to be a separate function because for we don't know if some parameters were unused
// until all the multiapps/subapps have been fully initialized - which isn't complete until
// *after* all the other member functions on Parser have been run.  So this is here to be
// externally called at the right time.
void
Parser::errorCheck(const Parallel::Communicator & comm, bool warn_unused, bool err_unused)
{
  // this if guard is important in case the simulation was not configured via parsed input text -
  // e.g.  configured programatically.
  if (!_root || !_cli_root)
    return;

  UnusedWalker uw(_input_filename, _extracted_vars, *this);
  UnusedWalker uwcli("CLI_ARG", _extracted_vars, *this);

  _root->walk(&uw);
  _cli_root->walk(&uwcli);

  auto cli = _app.commandLine();
  if (warn_unused)
  {
    for (auto arg : cli->unused(comm))
      _warnmsg +=
          errormsg("CLI_ARG", nullptr, "unused command line parameter '", cli->argv()[arg], "'") +
          "\n";
    for (auto & msg : uwcli.errors)
      _warnmsg += msg + "\n";
    for (auto & msg : uw.errors)
      _warnmsg += msg + "\n";
  }
  else if (err_unused)
  {
    for (auto arg : cli->unused(comm))
      _errmsg +=
          errormsg("CLI_ARG", nullptr, "unused command line parameter '", cli->argv()[arg], "'") +
          "\n";
    for (auto & msg : uwcli.errors)
      _errmsg += msg + "\n";
    for (auto & msg : uw.errors)
      _errmsg += msg + "\n";
  }

  if (_warnmsg.size() > 0)
    mooseUnused(_warnmsg);
  if (_errmsg.size() > 0)
    mooseError(_errmsg);
}

void
Parser::initSyntaxFormatter(SyntaxFormatterType type, bool dump_mode)
{
  switch (type)
  {
    case INPUT_FILE:
      _syntax_formatter = libmesh_make_unique<InputFileFormatter>(dump_mode);
      break;
    case YAML:
      _syntax_formatter = libmesh_make_unique<YAMLFormatter>(dump_mode);
      break;
    default:
      mooseError("Unrecognized Syntax Formatter requested");
      break;
  }
}

void
Parser::buildJsonSyntaxTree(JsonSyntaxTree & root) const
{
  std::vector<std::pair<std::string, Syntax::ActionInfo>> all_names;

  for (const auto & iter : _syntax.getAssociatedTypes())
    root.addSyntaxType(iter.first, iter.second);

  for (const auto & iter : _syntax.getAssociatedActions())
  {
    Syntax::ActionInfo act_info = iter.second;
    /**
     * If the task is nullptr that means we need to figure out which task goes with this syntax for
     * the purpose of building the Moose Object part of the tree. We will figure this out by asking
     * the ActionFactory for the registration info.
     */
    if (act_info._task == "")
      act_info._task = _action_factory.getTaskName(act_info._action);

    all_names.push_back(std::make_pair(iter.first, act_info));
  }

  for (const auto & act_names : all_names)
  {
    const auto & act_info = act_names.second;
    const std::string & action = act_info._action;
    const std::string & task = act_info._task;
    const std::string act_name = act_names.first;
    InputParameters action_obj_params = _action_factory.getValidParams(action);
    bool params_added = root.addParameters("",
                                           act_name,
                                           false,
                                           action,
                                           true,
                                           &action_obj_params,
                                           _syntax.getLineInfo(act_name, action, ""),
                                           "");

    if (params_added)
    {
      auto tasks = _action_factory.getTasksByAction(action);
      for (auto & t : tasks)
      {
        auto info = _action_factory.getLineInfo(action, t);
        root.addActionTask(act_name, action, t, info);
      }
    }

    /**
     * We need to see if this action is inherited from MooseObjectAction. If it is, then we will
     * loop over all the Objects in MOOSE's Factory object to print them out if they have associated
     * bases matching the current task.
     */
    if (action_obj_params.have_parameter<bool>("isObjectAction") &&
        action_obj_params.get<bool>("isObjectAction"))
    {
      for (registeredMooseObjectIterator moose_obj = _factory.registeredObjectsBegin();
           moose_obj != _factory.registeredObjectsEnd();
           ++moose_obj)
      {
        InputParameters moose_obj_params = (moose_obj->second)();
        // Now that we know that this is a MooseObjectAction we need to see if it has been
        // restricted
        // in any way by the user.
        const std::vector<std::string> & buildable_types = action_obj_params.getBuildableTypes();

        // See if the current Moose Object syntax belongs under this Action's block
        if ((buildable_types.empty() || // Not restricted
             std::find(buildable_types.begin(), buildable_types.end(), moose_obj->first) !=
                 buildable_types.end()) &&                                 // Restricted but found
            moose_obj_params.have_parameter<std::string>("_moose_base") && // Has a registered base
            _syntax.verifyMooseObjectTask(moose_obj_params.get<std::string>("_moose_base"),
                                          task) &&           // and that base is associated
            action_obj_params.mooseObjectSyntaxVisibility()) // and the Action says it's visible
        {
          std::string name;
          size_t pos = 0;
          bool is_action_params = false;
          bool is_type = false;
          if (act_name[act_name.size() - 1] == '*')
          {
            pos = act_name.size();

            if (!action_obj_params.collapseSyntaxNesting())
              name = act_name.substr(0, pos - 1) + moose_obj->first;
            else
            {
              name = act_name.substr(0, pos - 1) + "/<type>/" + moose_obj->first;
              is_action_params = true;
            }
          }
          else
          {
            name = act_name + "/<type>/" + moose_obj->first;
            is_type = true;
          }

          moose_obj_params.set<std::string>("type") = moose_obj->first;

          auto lineinfo = _factory.getLineInfo(moose_obj->first);
          std::string classname = _factory.associatedClassName(moose_obj->first);
          root.addParameters(act_name,
                             name,
                             is_type,
                             moose_obj->first,
                             is_action_params,
                             &moose_obj_params,
                             lineinfo,
                             classname);
        }
      }
    }
  }
  root.addGlobal();
}

void
Parser::buildFullTree(const std::string & search_string)
{
  std::vector<std::pair<std::string, Syntax::ActionInfo>> all_names;

  for (const auto & iter : _syntax.getAssociatedActions())
  {
    Syntax::ActionInfo act_info = iter.second;
    /**
     * If the task is nullptr that means we need to figure out which task goes with this syntax for
     * the purpose of building the Moose Object part of the tree. We will figure this out by asking
     * the ActionFactory for the registration info.
     */
    if (act_info._task == "")
      act_info._task = _action_factory.getTaskName(act_info._action);

    all_names.push_back(std::pair<std::string, Syntax::ActionInfo>(iter.first, act_info));
  }

  for (const auto & act_names : all_names)
  {
    InputParameters action_obj_params = _action_factory.getValidParams(act_names.second._action);
    _syntax_formatter->insertNode(
        act_names.first, act_names.second._action, true, &action_obj_params);

    const std::string & task = act_names.second._task;
    std::string act_name = act_names.first;

    /**
     * We need to see if this action is inherited from MooseObjectAction. If it is, then we will
     * loop over all the Objects in MOOSE's Factory object to print them out if they have associated
     * bases matching the current task.
     */
    if (action_obj_params.have_parameter<bool>("isObjectAction") &&
        action_obj_params.get<bool>("isObjectAction"))
    {
      for (registeredMooseObjectIterator moose_obj = _factory.registeredObjectsBegin();
           moose_obj != _factory.registeredObjectsEnd();
           ++moose_obj)
      {
        InputParameters moose_obj_params = (moose_obj->second)();
        /**
         * Now that we know that this is a MooseObjectAction we need to see if it has been
         * restricted in any way by the user.
         */
        const std::vector<std::string> & buildable_types = action_obj_params.getBuildableTypes();

        // See if the current Moose Object syntax belongs under this Action's block
        if ((buildable_types.empty() || // Not restricted
             std::find(buildable_types.begin(), buildable_types.end(), moose_obj->first) !=
                 buildable_types.end()) &&                                 // Restricted but found
            moose_obj_params.have_parameter<std::string>("_moose_base") && // Has a registered base
            _syntax.verifyMooseObjectTask(moose_obj_params.get<std::string>("_moose_base"),
                                          task) &&           // and that base is associated
            action_obj_params.mooseObjectSyntaxVisibility()) // and the Action says it's visible
        {
          std::string name;
          size_t pos = 0;
          bool is_action_params = false;
          if (act_name[act_name.size() - 1] == '*')
          {
            pos = act_name.size();

            if (!action_obj_params.collapseSyntaxNesting())
              name = act_name.substr(0, pos - 1) + moose_obj->first;
            else
            {
              name = act_name.substr(0, pos - 1) + "/<type>/" + moose_obj->first;
              is_action_params = true;
            }
          }
          else
          {
            name = act_name + "/<type>/" + moose_obj->first;
          }

          moose_obj_params.set<std::string>("type") = moose_obj->first;

          _syntax_formatter->insertNode(
              name, moose_obj->first, is_action_params, &moose_obj_params);
        }
      }
    }
  }

  // Do not change to _console, we need this printed to the stdout in all cases
  Moose::out << _syntax_formatter->print(search_string) << std::flush;
}

/**************************************************************************************************
 **************************************************************************************************
 *                                   Parameter Extraction Routines                                *
 **************************************************************************************************
 **************************************************************************************************/
using std::string;

// Template Specializations for retrieving special types from the input file
template <>
void Parser::setScalarParameter<RealVectorValue, RealVectorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<RealVectorValue> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<Point, Point>(const std::string & full_name,
                                              const std::string & short_name,
                                              InputParameters::Parameter<Point> * param,
                                              bool in_global,
                                              GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<PostprocessorName, PostprocessorName>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<PostprocessorName> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<MooseEnum, MooseEnum>(const std::string & full_name,
                                                      const std::string & short_name,
                                                      InputParameters::Parameter<MooseEnum> * param,
                                                      bool in_global,
                                                      GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<MultiMooseEnum, MultiMooseEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<MultiMooseEnum> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<ExecFlagEnum, ExecFlagEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<ExecFlagEnum> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void Parser::setScalarParameter<RealTensorValue, RealTensorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<RealTensorValue> * param,
    bool in_global,
    GlobalParamsAction * global_block);

// Vectors
template <>
void Parser::setVectorParameter<RealVectorValue, RealVectorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<RealVectorValue>> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void
Parser::setVectorParameter<Point, Point>(const std::string & full_name,
                                         const std::string & short_name,
                                         InputParameters::Parameter<std::vector<Point>> * param,
                                         bool in_global,
                                         GlobalParamsAction * global_block);

template <>
void Parser::setVectorParameter<MooseEnum, MooseEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<MooseEnum>> * param,
    bool in_global,
    GlobalParamsAction * global_block);

template <>
void Parser::setVectorParameter<VariableName, VariableName>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<VariableName>> * param,
    bool in_global,
    GlobalParamsAction * global_block);

void
Parser::extractParams(const std::string & prefix, InputParameters & p)
{
  std::ostringstream error_stream;
  static const std::string global_params_task = "set_global_params";
  static const std::string global_params_block_name =
      _syntax.getSyntaxByAction("GlobalParamsAction").front();

  ActionIterator act_iter = _action_wh.actionBlocksWithActionBegin(global_params_task);
  GlobalParamsAction * global_params_block = nullptr;

  // We are grabbing only the first
  if (act_iter != _action_wh.actionBlocksWithActionEnd(global_params_task))
    global_params_block = dynamic_cast<GlobalParamsAction *>(*act_iter);

  // Set a pointer to the current InputParameters object being parsed so that it can be referred
  // to
  // in the extraction routines
  _current_params = &p;
  _current_error_stream = &error_stream;
  for (const auto & it : p)
  {
    bool found = false;
    bool in_global = false;
    std::string orig_name = prefix + "/" + it.first;
    std::string full_name = orig_name;

    // Mark parameters appearing in the input file or command line
    if (_root->find(full_name) && _root->find(full_name)->type() == hit::NodeType::Field)
    {
      p.set_attributes(it.first, false);
      _extracted_vars.insert(
          full_name); // Keep track of all variables extracted from the input file
      found = true;
      p.inputLocation(it.first) =
          _input_filename + ":" + std::to_string(_root->find(full_name)->line());
      p.paramFullpath(it.first) = full_name;
    }
    // Wait! Check the GlobalParams section
    else if (global_params_block)
    {
      full_name = global_params_block_name + "/" + it.first;
      if (_root->find(full_name))
      {
        p.set_attributes(it.first, false);
        _extracted_vars.insert(
            full_name); // Keep track of all variables extracted from the input file
        found = true;
        in_global = true;
        p.inputLocation(it.first) =
            _input_filename + ":" + std::to_string(_root->find(full_name)->line());
        p.paramFullpath(it.first) = full_name;
      }
    }

    if (!found)
    {
      /**
       * Special case handling
       *   if the parameter wasn't found in the input file or the cli object the logic in this
       * branch will execute
       */

      // In the case where we have OutFileName but it wasn't actually found in the input filename,
      // we will populate it with the actual parsed filename which is available here in the
      // parser.

      InputParameters::Parameter<OutFileBase> * scalar_p =
          dynamic_cast<InputParameters::Parameter<OutFileBase> *>(it.second);
      if (scalar_p)
      {
        std::string input_file_name = getFileName();
        mooseAssert(input_file_name != "", "Input Filename is nullptr");
        size_t pos = input_file_name.find_last_of('.');
        mooseAssert(pos != std::string::npos, "Unable to determine suffix of input file name");
        scalar_p->set() = input_file_name.substr(0, pos) + "_out";
        p.set_attributes(it.first, false);
      }
    }
    else
    {
      if (p.isPrivate(it.first))
        mooseError("The parameter '",
                   full_name,
                   "' is a private parameter and should not be used in an input file.");

      auto par = it.second;
      auto short_name = it.first;

#define setscalarvaltype(ptype, base, range)                                                       \
  else if (par->type() == demangle(typeid(ptype).name()))                                          \
      setScalarValueTypeParameter<ptype, range, base>(                                             \
          full_name,                                                                               \
          short_name,                                                                              \
          dynamic_cast<InputParameters::Parameter<ptype> *>(par),                                  \
          in_global,                                                                               \
          global_params_block)
#define setscalar(ptype, base)                                                                     \
  else if (par->type() == demangle(typeid(ptype).name()))                                          \
      setScalarParameter<ptype, base>(full_name,                                                   \
                                      short_name,                                                  \
                                      dynamic_cast<InputParameters::Parameter<ptype> *>(par),      \
                                      in_global,                                                   \
                                      global_params_block)
#define setfpath(ptype)                                                                            \
  else if (par->type() == demangle(typeid(ptype).name()))                                          \
      setFilePathParam<ptype>(full_name,                                                           \
                              short_name,                                                          \
                              dynamic_cast<InputParameters::Parameter<ptype> *>(par),              \
                              p,                                                                   \
                              in_global,                                                           \
                              global_params_block)
#define setvector(ptype, base)                                                                     \
  else if (par->type() == demangle(typeid(std::vector<ptype>).name()))                             \
      setVectorParameter<ptype, base>(                                                             \
          full_name,                                                                               \
          short_name,                                                                              \
          dynamic_cast<InputParameters::Parameter<std::vector<ptype>> *>(par),                     \
          in_global,                                                                               \
          global_params_block)
#define setvectorfpath(ptype)                                                                      \
  else if (par->type() == demangle(typeid(std::vector<ptype>).name()))                             \
      setVectorFilePathParam<ptype>(                                                               \
          full_name,                                                                               \
          short_name,                                                                              \
          dynamic_cast<InputParameters::Parameter<std::vector<ptype>> *>(par),                     \
          p,                                                                                       \
          in_global,                                                                               \
          global_params_block)
#define setvectorvector(ptype)                                                                     \
  else if (par->type() == demangle(typeid(std::vector<std::vector<ptype>>).name()))                \
      setDoubleIndexParameter<ptype>(                                                              \
          full_name,                                                                               \
          short_name,                                                                              \
          dynamic_cast<InputParameters::Parameter<std::vector<std::vector<ptype>>> *>(par),        \
          in_global,                                                                               \
          global_params_block)

      /**
       * Scalar types
       */
      // built-ins
      // NOTE: Similar dynamic casting is done in InputParameters.C, please update appropriately
      if (false)
        ;
      setscalarvaltype(Real, double, Real);
      setscalarvaltype(int, int, long);
      setscalarvaltype(unsigned short, unsigned int, long);
      setscalarvaltype(long, int, long);
      setscalarvaltype(unsigned int, unsigned int, long);
      setscalarvaltype(unsigned long, unsigned int, long);
      setscalarvaltype(long int, int64_t, long);
      setscalarvaltype(unsigned long long, unsigned int, long);

      setscalar(bool, bool);
      setscalar(SubdomainID, int);
      setscalar(BoundaryID, int);

      // string and string-subclass types
      setscalar(string, string);
      setscalar(SubdomainName, string);
      setscalar(BoundaryName, string);
      setfpath(FileName);
      setfpath(MeshFileName);
      setfpath(FileNameNoExtension);
      setscalar(OutFileBase, string);
      setscalar(VariableName, string);
      setscalar(NonlinearVariableName, string);
      setscalar(AuxVariableName, string);
      setscalar(FunctionName, string);
      setscalar(UserObjectName, string);
      setscalar(VectorPostprocessorName, string);
      setscalar(IndicatorName, string);
      setscalar(MarkerName, string);
      setscalar(MultiAppName, string);
      setscalar(OutputName, string);
      setscalar(MaterialPropertyName, string);
      setscalar(MaterialName, string);
      setscalar(DistributionName, string);
      setscalar(SamplerName, string);
      setscalar(TagName, string);
      setscalar(MeshGeneratorName, string);

      setscalar(PostprocessorName, PostprocessorName);

      // Moose Compound Scalars
      setscalar(RealVectorValue, RealVectorValue);
      setscalar(Point, Point);
      setscalar(MooseEnum, MooseEnum);
      setscalar(MultiMooseEnum, MultiMooseEnum);
      setscalar(RealTensorValue, RealTensorValue);
      setscalar(ExecFlagEnum, ExecFlagEnum);

      // vector types
      setvector(Real, double);
      setvector(int, int);
      setvector(long, int);
      setvector(unsigned int, int);

// We need to be able to parse 8-byte unsigned types when
// libmesh is configured --with-dof-id-bytes=8.  Officially,
// libmesh uses uint64_t in that scenario, which is usually
// equivalent to 'unsigned long long'.  Note that 'long long'
// has been around since C99 so most C++ compilers support it,
// but presumably uint64_t is the "most standard" way to get a
// 64-bit unsigned type, so we'll stick with that here.
#if LIBMESH_DOF_ID_BYTES == 8
      setvector(uint64_t, int);
#endif

      setvector(SubdomainID, int);
      setvector(BoundaryID, int);
      setvector(RealVectorValue, double);
      setvector(Point, Point);
      setvector(MooseEnum, MooseEnum);

      setvector(string, string);
      setvectorfpath(FileName);
      setvectorfpath(FileNameNoExtension);
      setvectorfpath(MeshFileName);
      setvector(SubdomainName, string);
      setvector(BoundaryName, string);
      setvector(NonlinearVariableName, string);
      setvector(AuxVariableName, string);
      setvector(FunctionName, string);
      setvector(UserObjectName, string);
      setvector(IndicatorName, string);
      setvector(MarkerName, string);
      setvector(MultiAppName, string);
      setvector(PostprocessorName, string);
      setvector(VectorPostprocessorName, string);
      setvector(OutputName, string);
      setvector(MaterialPropertyName, string);
      setvector(MaterialName, string);
      setvector(DistributionName, string);
      setvector(SamplerName, string);
      setvector(TagName, string);
      setvector(VariableName, VariableName);
      setvector(MeshGeneratorName, string);

      // Double indexed types
      setvectorvector(Real);
      setvectorvector(int);
      setvectorvector(long);
      setvectorvector(unsigned int);
      setvectorvector(unsigned long long);

// See vector type explanation
#if LIBMESH_DOF_ID_BYTES == 8
      setvectorvector(uint64_t);
#endif

      setvectorvector(SubdomainID);
      setvectorvector(BoundaryID);
      setvectorvector(string);
      setvectorvector(FileName);
      setvectorvector(FileNameNoExtension);
      setvectorvector(MeshFileName);
      setvectorvector(SubdomainName);
      setvectorvector(BoundaryName);
      setvectorvector(VariableName);
      setvectorvector(NonlinearVariableName);
      setvectorvector(AuxVariableName);
      setvectorvector(FunctionName);
      setvectorvector(UserObjectName);
      setvectorvector(IndicatorName);
      setvectorvector(MarkerName);
      setvectorvector(MultiAppName);
      setvectorvector(PostprocessorName);
      setvectorvector(VectorPostprocessorName);
      setvectorvector(MarkerName);
      setvectorvector(OutputName);
      setvectorvector(MaterialPropertyName);
      setvectorvector(MaterialName);
      setvectorvector(DistributionName);
      setvectorvector(SamplerName);
      else
      {
        mooseError("unsupported type '", par->type(), "' for input parameter '", full_name, "'");
      }

#undef setscalarValueType
#undef setscalar
#undef setvector
#undef setvectorvector
    }
  }

  // All of the parameters for this object have been extracted.  See if there are any errors
  if (!error_stream.str().empty())
    mooseError(error_stream.str());

  // Here we will see if there are any auto build vectors that need to be created
  std::map<std::string, std::pair<std::string, std::string>> auto_build_vectors =
      p.getAutoBuildVectors();
  for (const auto & it : auto_build_vectors)
  {
    // We'll autogenerate values iff the requested vector is not valid but both the base and
    // number
    // are valid
    const std::string & base_name = it.second.first;
    const std::string & num_repeat = it.second.second;

    if (!p.isParamValid(it.first) && p.isParamValid(base_name) && p.isParamValid(num_repeat))
    {
      unsigned int vec_size = p.get<unsigned int>(num_repeat);
      const std::string & name = p.get<std::string>(base_name);

      std::vector<VariableName> variable_names(vec_size);
      for (unsigned int i = 0; i < vec_size; ++i)
      {
        std::ostringstream oss;
        oss << name << i;
        variable_names[i] = oss.str();
      }

      // Finally set the autogenerated vector into the InputParameters object
      p.set<std::vector<VariableName>>(it.first) = variable_names;
    }
  }
}

template <typename T>
bool
toBool(const std::string & /*s*/, T & /*val*/)
{
  return false;
}

template <>
bool
toBool<bool>(const std::string & s, bool & val)
{
  return hit::toBool(s, &val);
}

template <typename T, typename Base>
void
Parser::setScalarParameter(const std::string & full_name,
                           const std::string & short_name,
                           InputParameters::Parameter<T> * param,
                           bool in_global,
                           GlobalParamsAction * global_block)
{

  try
  {
    param->set() = _root->param<Base>(full_name);
  }
  catch (hit::Error & err)
  {
    auto strval = _root->param<std::string>(full_name);

    // handle the case where the user put a number inside quotes
    auto & t = typeid(T);
    if (t == typeid(int) || t == typeid(unsigned int) || t == typeid(SubdomainID) ||
        t == typeid(BoundaryID) || t == typeid(double))
    {
      try
      {
        param->set() = MooseUtils::convert<T>(strval, true);
      }
      catch (std::invalid_argument & /*e*/)
      {
        const std::string format_type = (t == typeid(double)) ? "float" : "integer";
        _errmsg += errormsg(_input_filename,
                            _root->find(full_name),
                            "invalid ",
                            format_type,
                            " syntax for parameter: ",
                            full_name,
                            "=",
                            strval) +
                   "\n";
      }
    }
    else if (t == typeid(bool))
    {
      bool isbool = toBool(strval, param->set());
      if (!isbool)
        _errmsg += errormsg(_input_filename,
                            _root->find(full_name),
                            "invalid boolean syntax for parameter: ",
                            full_name,
                            "=",
                            strval) +
                   "\n";
    }
    else
      throw;
  }

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<T>(short_name) = param->get();
  }
}

template <typename T>
void
Parser::setFilePathParam(const std::string & full_name,
                         const std::string & short_name,
                         InputParameters::Parameter<T> * param,
                         InputParameters & params,
                         bool in_global,
                         GlobalParamsAction * global_block)
{
  std::string prefix;
  std::string postfix = _root->param<std::string>(full_name);
  size_t pos = _input_filename.find_last_of('/');
  if (pos != std::string::npos && postfix[0] != '/' && !postfix.empty())
    prefix = _input_filename.substr(0, pos + 1);

  params.rawParamVal(short_name) = postfix;
  param->set() = prefix + postfix;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<T>(short_name) = param->get();
  }
}

template <typename T, typename UP_T, typename Base>
void
Parser::setScalarValueTypeParameter(const std::string & full_name,
                                    const std::string & short_name,
                                    InputParameters::Parameter<T> * param,
                                    bool in_global,
                                    GlobalParamsAction * global_block)
{
  setScalarParameter<T, Base>(full_name, short_name, param, in_global, global_block);

  // If this is a range checked param, we need to make sure that the value falls within the
  // requested range
  mooseAssert(_current_params, "Current params is nullptr");

  _current_params->rangeCheck<T, UP_T>(full_name, short_name, param, *_current_error_stream);
}

template <typename T, typename Base>
void
Parser::setVectorParameter(const std::string & full_name,
                           const std::string & short_name,
                           InputParameters::Parameter<std::vector<T>> * param,
                           bool in_global,
                           GlobalParamsAction * global_block)
{
  std::vector<T> vec;
  if (_root->find(full_name))
  {
    try
    {
      auto tmp = _root->param<std::vector<Base>>(full_name);
      for (auto val : tmp)
        vec.push_back(val);
    }
    catch (hit::Error & err)
    {
      _errmsg += errormsg(_input_filename, _root->find(full_name), err.what());
      return;
    }
  }

  param->set() = vec;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setVectorParam<T>(short_name).resize(param->get().size());
    for (unsigned int i = 0; i < vec.size(); ++i)
      global_block->setVectorParam<T>(short_name)[i] = param->get()[i];
  }
}

template <typename T>
void
Parser::setVectorFilePathParam(const std::string & full_name,
                               const std::string & short_name,
                               InputParameters::Parameter<std::vector<T>> * param,
                               InputParameters & params,
                               bool in_global,
                               GlobalParamsAction * global_block)
{
  std::vector<T> vec;
  std::vector<std::string> rawvec;
  if (_root->find(full_name))
  {
    auto tmp = _root->param<std::vector<std::string>>(full_name);
    params.rawParamVal(short_name) = _root->param<std::string>(full_name);
    for (auto val : tmp)
    {
      std::string prefix;
      std::string postfix = val;
      size_t pos = _input_filename.find_last_of('/');
      if (pos != std::string::npos && postfix[0] != '/')
        prefix = _input_filename.substr(0, pos + 1);
      rawvec.push_back(postfix);
      vec.push_back(prefix + postfix);
    }
  }

  param->set() = vec;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setVectorParam<T>(short_name).resize(param->get().size());
    for (unsigned int i = 0; i < vec.size(); ++i)
      global_block->setVectorParam<T>(short_name)[i] = param->get()[i];
  }
}

template <typename T>
void
Parser::setDoubleIndexParameter(const std::string & full_name,
                                const std::string & short_name,
                                InputParameters::Parameter<std::vector<std::vector<T>>> * param,
                                bool in_global,
                                GlobalParamsAction * global_block)
{
  // Get the full string assigned to the variable full_name
  std::string buffer = _root->param<std::string>(full_name);

  // split vector at delim ;
  // NOTE: the substrings are _not_ of type T yet
  std::vector<std::string> first_tokenized_vector;
  MooseUtils::tokenize(buffer, first_tokenized_vector, 1, ";");
  param->set().resize(first_tokenized_vector.size());

  for (unsigned j = 0; j < first_tokenized_vector.size(); ++j)
    if (!MooseUtils::tokenizeAndConvert<T>(first_tokenized_vector[j], param->set()[j]))
    {
      _errmsg += errormsg(
          _input_filename, _root->find(full_name), "invalid format for parameter ", full_name);
      return;
    }

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setDoubleIndexParam<T>(short_name).resize(first_tokenized_vector.size());
    for (unsigned j = 0; j < first_tokenized_vector.size(); ++j)
    {
      global_block->setDoubleIndexParam<T>(short_name)[j].resize(param->get()[j].size());
      for (unsigned int i = 0; i < param->get()[j].size(); ++i)
        global_block->setDoubleIndexParam<T>(short_name)[j][i] = param->get()[j][i];
    }
  }
}

template <typename T>
void
Parser::setScalarComponentParameter(const std::string & full_name,
                                    const std::string & short_name,
                                    InputParameters::Parameter<T> * param,
                                    bool in_global,
                                    GlobalParamsAction * global_block)
{
  std::vector<double> vec;
  try
  {
    vec = _root->param<std::vector<double>>(full_name);
  }
  catch (hit::Error & err)
  {
    _errmsg += errormsg(_input_filename, _root->find(full_name), err.what());
    return;
  }

  if (vec.size() != LIBMESH_DIM)
  {
    _errmsg += errormsg(_input_filename,
                        _root->find(full_name),
                        "wrong number of values in scalar component parameter ",
                        full_name,
                        ": size ",
                        vec.size(),
                        " is not a multiple of ",
                        LIBMESH_DIM);
    return;
  }

  T value;
  for (unsigned int i = 0; i < vec.size(); ++i)
    value(i) = Real(vec[i]);

  param->set() = value;
  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<T>(short_name) = value;
  }
}

template <typename T>
void
Parser::setVectorComponentParameter(const std::string & full_name,
                                    const std::string & short_name,
                                    InputParameters::Parameter<std::vector<T>> * param,
                                    bool in_global,
                                    GlobalParamsAction * global_block)
{
  std::vector<double> vec;
  try
  {
    vec = _root->param<std::vector<double>>(full_name);
  }
  catch (hit::Error & err)
  {
    _errmsg += errormsg(_input_filename, _root->find(full_name), err.what());
    return;
  }

  if (vec.size() % LIBMESH_DIM)
  {
    _errmsg += errormsg(_input_filename,
                        _root->find(full_name),
                        "wrong number of values in vector component parameter ",
                        full_name,
                        ": size ",
                        vec.size(),
                        " is not a multiple of ",
                        LIBMESH_DIM);
    return;
  }

  std::vector<T> values;
  for (unsigned int i = 0; i < vec.size() / LIBMESH_DIM; ++i)
  {
    T value;
    for (int j = 0; j < LIBMESH_DIM; ++j)
      value(j) = Real(vec[i * LIBMESH_DIM + j]);
    values.push_back(value);
  }

  param->set() = values;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setVectorParam<T>(short_name).resize(vec.size(), values[0]);
    for (unsigned int i = 0; i < vec.size() / LIBMESH_DIM; ++i)
      global_block->setVectorParam<T>(short_name)[i] = values[0];
  }
}

template <>
void
Parser::setScalarParameter<RealVectorValue, RealVectorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<RealVectorValue> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  setScalarComponentParameter(full_name, short_name, param, in_global, global_block);
}

template <>
void
Parser::setScalarParameter<Point, Point>(const std::string & full_name,
                                         const std::string & short_name,
                                         InputParameters::Parameter<Point> * param,
                                         bool in_global,
                                         GlobalParamsAction * global_block)
{
  setScalarComponentParameter(full_name, short_name, param, in_global, global_block);
}

template <>
void
Parser::setScalarParameter<MooseEnum, MooseEnum>(const std::string & full_name,
                                                 const std::string & short_name,
                                                 InputParameters::Parameter<MooseEnum> * param,
                                                 bool in_global,
                                                 GlobalParamsAction * global_block)
{
  MooseEnum current_param = param->get();

  std::string value = _root->param<std::string>(full_name);

  param->set() = value;
  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<MooseEnum>(short_name) = current_param;
  }
}

template <>
void
Parser::setScalarParameter<MultiMooseEnum, MultiMooseEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<MultiMooseEnum> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  MultiMooseEnum current_param = param->get();

  auto vec = _root->param<std::vector<std::string>>(full_name);

  std::string raw_values;
  for (unsigned int i = 0; i < vec.size(); ++i)
    raw_values += ' ' + vec[i];

  param->set() = raw_values;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<MultiMooseEnum>(short_name) = current_param;
  }
}

template <>
void
Parser::setScalarParameter<ExecFlagEnum, ExecFlagEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<ExecFlagEnum> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  ExecFlagEnum current_param = param->get();
  auto vec = _root->param<std::vector<std::string>>(full_name);

  std::string raw_values;
  for (unsigned int i = 0; i < vec.size(); ++i)
    raw_values += ' ' + vec[i];

  param->set() = raw_values;

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<ExecFlagEnum>(short_name) = current_param;
  }
}

template <>
void
Parser::setScalarParameter<RealTensorValue, RealTensorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<RealTensorValue> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  auto vec = _root->param<std::vector<double>>(full_name);
  if (vec.size() != LIBMESH_DIM * LIBMESH_DIM)
  {
    _errmsg += errormsg(_input_filename,
                        _root->find(full_name),
                        "invalid RealTensorValue parameter ",
                        full_name,
                        ": size is ",
                        vec.size(),
                        " but should be ",
                        LIBMESH_DIM * LIBMESH_DIM);
    return;
  }

  RealTensorValue value;
  for (int i = 0; i < LIBMESH_DIM; ++i)
    for (int j = 0; j < LIBMESH_DIM; ++j)
      value(i, j) = Real(vec[i * LIBMESH_DIM + j]);

  param->set() = value;
  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<RealTensorValue>(short_name) = value;
  }
}

// Specialization for coupling a Real value where a postprocessor would be needed in MOOSE
template <>
void
Parser::setScalarParameter<PostprocessorName, PostprocessorName>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<PostprocessorName> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  PostprocessorName pps_name = _root->param<std::string>(full_name);
  param->set() = pps_name;

  Real real_value = -std::numeric_limits<Real>::max();
  std::istringstream ss(pps_name);

  if (ss >> real_value && ss.eof())
    _current_params->setDefaultPostprocessorValue(short_name, real_value);

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setScalarParam<PostprocessorName>(short_name) = pps_name;
  }
}

template <>
void
Parser::setVectorParameter<RealVectorValue, RealVectorValue>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<RealVectorValue>> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  setVectorComponentParameter(full_name, short_name, param, in_global, global_block);
}

template <>
void
Parser::setVectorParameter<Point, Point>(const std::string & full_name,
                                         const std::string & short_name,
                                         InputParameters::Parameter<std::vector<Point>> * param,
                                         bool in_global,
                                         GlobalParamsAction * global_block)
{
  setVectorComponentParameter(full_name, short_name, param, in_global, global_block);
}

template <>
void
Parser::setVectorParameter<MooseEnum, MooseEnum>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<MooseEnum>> * param,
    bool in_global,
    GlobalParamsAction * global_block)
{
  std::vector<MooseEnum> enum_values = param->get();
  std::vector<std::string> values(enum_values.size());
  for (unsigned int i = 0; i < values.size(); ++i)
    values[i] = static_cast<std::string>(enum_values[i]);

  /**
   * With MOOSE Enums we need a default object so it should have been passed in the param pointer.
   * We are only going to use the first item in the vector (values[0]) and ignore the rest.
   */
  std::vector<std::string> vec;
  if (_root->find(full_name))
  {
    vec = _root->param<std::vector<std::string>>(full_name);
    param->set().resize(vec.size(), enum_values[0]);
  }

  for (unsigned int i = 0; i < vec.size(); ++i)
    param->set()[i] = vec[i];

  if (in_global)
  {
    global_block->remove(short_name);
    global_block->setVectorParam<MooseEnum>(short_name).resize(vec.size(), enum_values[0]);
    for (unsigned int i = 0; i < vec.size(); ++i)
      global_block->setVectorParam<MooseEnum>(short_name)[i] = values[0];
  }
}

/**
 * Specialization for coupling vectors. This routine handles default values and auto generated
 * VariableValue vectors.
 */
template <>
void
Parser::setVectorParameter<VariableName, VariableName>(
    const std::string & full_name,
    const std::string & short_name,
    InputParameters::Parameter<std::vector<VariableName>> * param,
    bool /*in_global*/,
    GlobalParamsAction * /*global_block*/)
{
  auto vec = _root->param<std::vector<std::string>>(full_name);
  auto strval = _root->param<std::string>(full_name);
  std::vector<VariableName> var_names(vec.size());

  bool has_var_names = false;
  for (unsigned int i = 0; i < vec.size(); ++i)
  {
    VariableName var_name = vec[i];

    Real real_value;
    std::istringstream ss(var_name);

    // If we are able to convert this value into a Real, then set a default coupled value
    // NOTE: parameter must be either all default or no defaults
    if (ss >> real_value && ss.eof())
      _current_params->defaultCoupledValue(short_name, real_value, i);
    else
    {
      var_names[i] = var_name;
      has_var_names = true;
    }
  }

  if (has_var_names)
  {
    param->set().resize(vec.size());

    for (unsigned int i = 0; i < vec.size(); ++i)
      if (var_names[i] == "")
      {
        _errmsg += errormsg(
            _input_filename,
            _root->find(full_name),
            "invalid value for ",
            full_name,
            ":\n"
            "    MOOSE does not currently support a coupled vector where some parameters are ",
            "reals and others are variables");
        return;
      }
      else
        param->set()[i] = var_names[i];
  }
}
